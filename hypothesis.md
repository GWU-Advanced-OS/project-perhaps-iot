## Questions  

1. Summarize the project, what it is, what its goals are, and why it exists.
2. What is the target domain of the system? Where is it valuable, and where is it not a good fit? These are all implemented in an engineering domain, thus are the product of trade-offs. No system solves all problems (despite the claims of marketing material).
3. What are the "modules" of the system (see early lectures), and how do they relate? Where are isolation boundaries present? How do the modules communicate with each other? What performance implications does this structure have?
4. What are the core abstractions that the system aims to provide. How and why do they depart from other systems?
5. In what conditions is the performance of the system "good" and in which is it "bad"? How does its performance compare to a Linux baseline (this discussion can be quantitative or qualitative)?
6. What are the core technologies involved, and how are they composed?
7. What are the security properties of the system? How does it adhere to the principles for secure system design? What is the reference monitor in the system, and how does it provide complete mediation, tamperproof-ness, and how does it argue trustworthiness?
8. What optimizations exist in the system? What are the "key operations" that the system treats as a fast-path that deserve optimization? How does it go about optimizing them?
9. Subjective: What do you like, and what don't you like about the system? What could be done better were you to re-design it?


## Hypothesis
#### Our hypothesized answers to the above questions, with links to docs/code that gives us this impression.
1. Azure RTOS ThreadX is an RTOS designed specifically for multithreaded and safety-critical embedded applications. It acheives this goal by providing conventional RTOS features such as priority inheritance and deterministic processing, as well as features unique to ThreadX such as premption-thresholds (the ability to determine the need for preemptive versus non-premptive scheduling) and memory protection provided by Modules (bundled application threads that can be dynamically loaded and run on the target). It exists because Bill Lamie, the creator of ThreadX, wanted to improve on
prior RTOSes he created (Nucleus RTX and Nucleus PLUS). Lamie's primary
motivation in creating all of these RTOSes was to make them simple and easy to
use. 
   (https://docs.microsoft.com/en-us/azure/rtos/threadx/chapter1#multitasking)
(https://www.cs.utah.edu/~regehr/reading/open_papers/preempt_thresh.pdf)
  (https://www.embedded.com/bill-lamie-story-of-a-man-and-his-real-time-operating-systems/)  
2. This system is specifically made for embedded, multitasked scenarios. That
   is, it is not optimal for non-embedded applications, nor for applications
that don't require several tasks being done concurrently. Actual applications
of ThreadX share a common need for real-time systems with a small memory footprint and multitasking abilities. 
(https://militaryembedded.com/comms/rf-and-microwave/case-bullseye-million-miles-away)
3. The core modules of ThreadX are threads and ThreadX modules. 
Isolation is provided through ThreadX Modules (https://docs.microsoft.com/en-us/azure/rtos/threadx-modules/chapter1).
![Alt text](https://docs.microsoft.com/en-us/azure/rtos/threadx-modules/media/image2.png "a title") 
The modules communicate via a ThreadX Module api (https://docs.microsoft.com/en-us/azure/rtos/threadx-modules/chapter4).
ThreadX modules provide dynamic memory management so that several large modules can be running on little memory by only allocating memory to the specific thread running, not the whole module. 
4. ThreadX aims to provide scheduling, communication, synchronization, timer, memory management, and interrupt management facilities for embedded, real-time, and IoT applications. ThreadX is a component of the larger Azure RTOS (as seen in this dependency diagram: https://github.com/azure-rtos/threadx#understanding-inter-component-dependencies). This design differs from more traditional OS's like Linux and Plan9., which have a more monolithic architecture.  
5. ThreadX is a specialized OS (use case is embedded, real-time, IoT) and benchmarking places it to be faster than most other commercial RTOSes (benchmarking data: https://docs.microsoft.com/en-us/azure/rtos/threadx/overview-threadx#fast-execution ). Since it has a specific use case, if the conditions aren't in line with the use case, the perfance will likely be sub optimal since the system is so specialized. It's difficult to compare Linux and ThreadX since the use cases are very different, but I did find a paper (https://webthesis.biblio.polito.it/8505/1/tesi.pdf) that discusses benchmarking embedded Linux. Unfortunately, the same tests aren't conducted on both Linux and ThreadX so they can't directly be compared; however, the information found was still interesting.  
6. ThreadX consists of four types of program execution: Initialization, Thread Execution, Interrupt Service Routines (ISRs), and Application Timers. Each of these execution modes consists of different components, but generally each mode consists of memory usage (static, dynamic), interrupts, threads, application definition, preemption, scheduling algorithms (round robin, time slice), and message queue management.  
7. RTOS ThreadX allows for the creating of modules that bundle multiple applications to by dynamically loaded in their own address space for memory protection and if other components are compromised, the module will remain secure. (https://docs.microsoft.com/en-us/azure/rtos/threadx/overview-threadx#memory-protection-via-azure-rtos-threadx-modules) Given that RTOS ThreadX is based on the assumption that multiple threads will be running at any given time and preemption is allowed, it is important to note that ThreadX uses round-robin scheduling to allow threads with the same priority to execute even if the current executing thread has not completed or relinquished runtime. (https://docs.microsoft.com/en-us/azure/rtos/threadx/chapter3#thread-scheduling) A time-slice can be specified which essentially acts a timeout for threads so no single thread can consume all system resources, and must relinquish running status if they have hit a maximum number of cycles. (https://docs.microsoft.com/en-us/azure/rtos/threadx/chapter3#time-slicing) 
	ThreadX includes support for semaphones(used for mutual exclusion) which includes the possibility of deadlock to occur in the system. In order to reduce this likelihood, each thread is only allowed to hold a single semaphone at a time or, if using more than one semaphone can do so only if accessing them in the same order each time, however it is still possible to causes deadlock on purpose within this system. (https://docs.microsoft.com/en-us/azure/rtos/threadx/chapter3#deadly-embrace)
	For other security concerns, it is possible a thread can cause corrupt memory in its stack area by using recursive algorithms or anything else that causes excessive stack usage. This can cause unpredictable changes within the system including changing the program counter. This is a weakness within the security of memory in this system, as the only way to prevent this issue is for the user to not create threads that consume large amounts of stack area. Not only is this not secure for malicious users, but could even occur unintentionally. (https://docs.microsoft.com/en-us/azure/rtos/threadx/chapter3#memory-pitfalls)
	In general, I would say the system argues security by the use of additional security-based plugins and software, and does not emphasize the security of the system itself. Most security features are only those inherent to a microkernel and the fact that if one module is compromised, it allows for other modules to continue, however there is a serious concern for tamperability as demonstrated above. A user can unintentionally tamper with this system by using it wrong. It's important to note the usage of this operating system in embedded systems and its reliability in strict circumstances, but as a general operating system, it has some security concerns. 
8. RTOS Threadx claims to have what they call a "picokernel" that allows services to be layered and prevents extraneous system calls, which help reduce overhead during runtime. The do allow preemption for scheduling but are strategic about saving/restoring registers, have up to 1024 priority levels, and attempt to reduce context switching when possible. (https://docs.microsoft.com/en-us/azure/rtos/threadx/overview-threadx#advanced-technology)
9. In general, I think this OS provides a very fast and optimized use for embedded systems and specific use cases. I don't think its particularly specific to this OS that it would struggle in certain circumstances and thrive in others, however I would say the use case is fairly narrow. It heavily relies on the expertise of the user in order to take advantage of the optimizations of system and corruptions in memory can occur by accident by an unskilled user. These are security concerns that I think could be addressed better than just saying "hey, don't do that" which is essentially the suggestion given within the docs. However, if a multi-threaded real time system with a large amount of threads with frequent changes in execution are what you need, the ability for this OS to reduce overhead with context switching and optimize for many threads executing at once is ideal.

